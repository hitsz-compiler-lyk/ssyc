# 后端架构简介

对于后端而言，主要分为了四个部分：

IR --> LIR (Low level IR)

寄存器分配

后端优化

LIR -- > ArmCode

## 继承体系与类别总览

LIR的指令和操作数体系如下：

```
ArmFunction
    > ArmBlock
        > ArmInst
            > Unary
                : INeg, FNeg,
            > Binary
                : IAdd, ISub, IRsb, IMul, IDiv, ILMul, FAdd, FSub, FMul, FDiv, Bic
            > Terney
                : IMulAdd, IMulSub, FMulAdd, FMulSub,
            > FloatToInt
            > IntToFloat
            > Move
            > Call
            > Return
            > Load
            > Store
            > Branch
            > Cmp
            > StackOp
                : ParamLoad, StackAddr, StackLoad, StackStore

Operand
    > Addr
    > Imm
        > IImm
        > FImm
    > Reg
        > IPhyReg
        > FPhyReg
        > IVirtualReg
        > FVirtualReg
```

对于ArmInst均是参考Arm指令设计而来, 其都共有着
cond: Any, Ge, Gt, Eq, Ne, Le, Lt
> 表示改指令在什么情况下执行（目前只有Branch跳转指令、MOV指令和BranchToCond优化涉及）

> (对于比赛用例的中, 出现了浮点数Nan的比较, 因而应该将Le改用Ls,Lt改用Mi,而Ge改用Pl,Gt改用Hi不需要添加)

operands：表示该指令所拥有的操作数
> 并不是所有的指令都拥有操作数 比如Return和Branch指令 每个指令所拥有的操作数个数也不一定相同，比如Binary就有三个操作数 而Ternay则有四个操作数

Shift: Arm汇编中的第2个操作数
> 表示的是对于，用于在计算时实现移位操作

### 栈结构

对于在 Linux ARM 上, 栈向低地址方向增长, 高地址是栈顶

对于从IR -> LIR的过程中的Alloc称为CAlloc 而寄存器分配过程中的Alloc称为Alloc

对于某个函数的最终的栈结构:

```
┌────────────────────────────┐
│                            │
│       ParameterX  4        │
├────────────────────────────┤
│                            │
│           ......           │
├────────────────────────────┤
│                            │
│       Parameter2  4        │
├────────────────────────────┤
│                            │
│       Parameter1  4        │
├────────────────────────────┤
│                            │
│                            │
│                            │
│         CAllocZ   Nz       │
│                            │
│                            │
├────────────────────────────┤
│                            │
│           ......           │
│                            │
├────────────────────────────┤
│                            │
│         CAlloc1   N1       │
│                            │
├────────────────────────────┤
│                            │
│         AllocY    4        │
├────────────────────────────┤
│                            │
│           ......           │
├────────────────────────────┤
│                            │
│         Alloc2    4        │
├────────────────────────────┤
│                            │
│         Alloc1    4        │
└────────────────────────────┘
```

其对应的指令效果如下:
```
                                ┌────────────────────────────┐
                                │                            │
                                │       ParameterX  4        │
                                ├────────────────────────────┤
                                │                            │
                                │           ......           │
                                ├────────────────────────────┤
                                │                            │
                                │       Parameter2  4        │
                                ├────────────────────────────┤
                                │                            │
 ┌────────────┐                 │       Parameter1  4        │
 │            ├─────────┐       ├────────────────────────────┤
 │   Alloc1   │         │       │                            │
 └─────┬──────┘         │       │                            │
    ...│...             │       │                            │
       ▼          ┌─────┼──────►│         CAllocZ   Nz       │
 ┌────────────┐   │     │       │                            │
 │            │   │     │       │                            │
 │  CAlloc 1  ├───┼──┐  │       ├────────────────────────────┤
 └─────┬──────┘   │  │  │       │                            │
    ...│...       │  │  │       │           ......           │
       ▼          │  │  │       │                            │
 ┌────────────┐   │  │  │       ├────────────────────────────┤
 │            |   |  └──┼──────►│                            │
 │   Alloc2   ├───┼─┐   │       │         CAlloc1   N1       │
 └─────┬──────┘   │ │   │       │                            │
    ...│...       │ │   │       ├────────────────────────────┤
       ▼          │ │ ┌─┼──────►│                            │
 ┌────────────┐   │ │ │ │       │         AllocY    4        │
 │            │   │ │ │ │       ├────────────────────────────┤
 │  CAlloc Z  ├───┘ │ │ │       │                            │
 └─────┬──────┘     │ │ │       │           ......           │
    ...│...         │ │ │       │────────────────────────────┤
       ▼            │ │ │       │                            │
 ┌────────────┐     └─┼─┼──────►│         Alloc2    4        │
 │            │       │ │       ├────────────────────────────┤
 │   AllocY   ├───────┘ └──────►│                            │
 └────────────┘                 │         Alloc1    4        │
                                └────────────────────────────┘
```
对于一个函数最终的栈而言, 其最低层是寄存器分配所导致的Alloc，再往上是CAlloc所分配的空间, 再往上是该函数传入的在栈中的参数，这个最终的栈结果和按照顺序生成的结果并不一样，因而按照处理顺序，是先获得了CAlloc的栈情况，在获得寄存器分配的Alloc的栈分配，但实际上为了更优秀的性能，因为访问寄存器分配的Alloc的栈分配情况更加的平凡，同时如果在栈上申请了一个较大空间，将寄存器分配的Alloc放在栈底也不用进行计算出偏移量再寻址(当偏移量超过+-4095(vfp为+-1020)时,无法直接通过Load Store进行偏移量寻址)，同时也更好的支持申请不定长度数组的情况(只需要处理CAlloc和调用函数的情况，并不用处理寄存器分配时的偏移量，本项目并未实现)

对于栈上的Load和Store等操作，均特化出了全新的类:

> ParamLoad  StackAddr  StackLoad  StackStore

ParamLoad用于函数参数的Load，因为其栈修复的特殊性，因而单列

StackLoad,StackStore用于寄存器分配时的在栈上的Load和Store

StackAddr用于表示一个基址或者一个CAlloc的在栈上的地址，当表示为一个基址时，它会捆绑多个ParamLoad,StackLoad,StackStore，从而保值所有的ParamLoad,StackLoad,StackStore都可以用`Ldr/Str 基址 相对偏移量`的方式来完成，因而不会出现多个Load和Store需要通过`ADD 地址 SP 偏移量` + `Ldr/Str 地址`的方式完成操作。实际上StackAddr为`ADD 基址 SP 偏移量`，其中保证了偏移量为n * 1024，这样保证了只有当`n > 2^8`才需要额外的MOVE操作，这里和Arm立即数的表示关系相关。

这部分和栈修复有关，通过上述优化后栈修复逻辑相对复杂，因而抽象出上述的指令进行处理。

## 寄存器分配

目前本项目寄存器分配采用的是简单的图着色寄存器，相较于完整的图着色寄存器分配缺少了coalesce优化

因为栈修复相关的逻辑，因而不能在寄存器分配的时候就确定下来某个虚拟寄存器对应替换为某个物理寄存器，因而每次寄存器分配后返回一个map，为虚拟寄存器到物理寄存器的映射

在本项目中有一些独特的优化，比如对于立即数和基址，可以不压入栈中，直接重新使用一个MOVE/ADD指令替换Load指令，同时尝试将局部（一个基本块内）的spill的同一个寄存器重新恢复为一个虚拟寄存器，再进行重新寄存器分配

在寄存器分配时对于选择spill节点的方式有待优化，本项目试过考虑引入循环深度、使用次数等参数，但并不能找到一个很好的拟合函数表示权值，另外参考其他项目可以考虑采用机器/深度学习，马尔科夫链等内容实现

## 后端优化

### 立即数乘除模

本项目当中添加了所有情况下的立即数除模优化，但除了对于`2^n`的特殊情况下有实际效果，其余效果并不明显

对于立即数乘法，只考虑对于下述情况进行优化:

$$\mid x \mid = 2^x \pm 2^y / 0 \quad (x \geq y)$$

对于立即数模，只会对`2^n`和`0`的特殊情况进行优化

立即数模其本身等价于 x % y == x - (x / y) * y

其中模转换成的乘法和除法也可以继续使用立即数乘除法优化

### 窥孔优化

目前采用的策略包括:

```
> 删除基本块相邻的直接跳转
> 调整有条件跳转的方向
> 替换LOAD/STORE寻址方式
> 删除无用的MOVE,LOAD,STORE等指令
> 三操作数指令变为四操作数指令
> 四则运算利用移位运算合并
......
```

上述优化可以总结为三个部分：跳转优化、删去无用指令、强度增强，但暂未有Load和Store的自增自减的强度增强（逻辑较为复杂，因正确性不好保证因而删除）

### BranchToCond

将一些小的基本块执行变为指令条件执行，这主要是优化如下场景
```c
if ( cond ) {
    do something simple
}
```

能够优化的条件如下:
```
1. 三个基本块相连，且跳转指令条件成功从第一个基本块跳转至第二个基本块，否则跳转至第三个基本块
2. 跳转条件不为无条件跳转
3. 第二个基本块只有一个前驱
4. 第二个基本块的前驱为第一个基本块
5. 第二个基本块只有一个后驱
6. 第二个基本块的后驱为第三个基本块
7. 第二个基本块指令条数小于等于4条
8. 第二个基本块指令中无比较，跳转，返回指令
9. 第二个基本块无条件执行指令（全部为Any）
```

BranchToCond优化配合IR的块重排可以起到更好的效果

## 后端杂谈

对于后端而言，在竞赛当中主要的优化点就在于尽可能的减少Load\Store和跳转的情况

这是因为一个Load/Store往往需要3-4个周期（具体几个周期我也没查到），跳转指令的执行确实只需要1个周期，但跳转指令会打断Arm的流水线，而Arm是三级流水线（取指、译码、执行），也就是说一个跳转指令相当于3个指令周期（但理论上应该有分支预测？），而其余的大部分计算都是1个周期，因此主要优化在这个上面

但本项目相较于以上的优化，还着重优化了海量函数参数，大量变量计算的场景，但是本竞赛当中并没有出这样并不符合实际场景的用例（为什么不像ACM一样出极端用例）

## Arm后端tips

### 开启向量化

通过修改fpscr实现

必须使用vmrs指令将fpscr加载到通用寄存器中，使用vmsr指令对寄存器进行操作，并将其移回fpscr

其通过设置len = 执行向量化的寄存器的个数，stride = 在vfp寄存器中执行向量化跳过的间隔

len的值存储在fpscr的第16至18位中, stride存储在fpscr的20至21位中, 其中因为0没有意义，因此000 = 1, ... , 111 = 8

### BSS段

BSS段通常是指用来存放程序中未初始化的全局变量的一块内存区域，其只记录占用空间的大小，由操作系统来负责清零

对于全0初始化的全局数组，如果使用DATA段则最后生成的可执行文件也会附带所占用这么大空间的0，导致生成的可执行文件巨大