grammar SysY;

options {
    backtrack = true;
    memoize = true;
    output = AST;
    ASTLabelType = CommonTree;
}

tokens {
    FuncDef         = 'FuncDef';
    FuncParamList   = 'FuncParamList';
    FuncParam       = 'FuncParam';
    ConstDef        = 'ConstDef';
    VarDef          = 'VarDef';
    InitList        = 'InitList';
    Block           = 'Block';
    StmtExp         = 'StmtExp';
    StmtAssign      = 'StmtAssign';
    StmtEmpty       = 'StmtEmpty';
    StmtBreak       = 'StmtBreak';
    StmtContinue    = 'StmtContinue';
    StmtReturn      = 'StmtReturn';
    StmtEmpty       = 'StmtEmpty';
    StmtIf          = 'StmtIf';
    StmtWhile       = 'StmtWhile';
    StmtPutf        = 'StmtPutf';
    LogOp           = 'LogOp';
    RelOp           = 'RelOp';
    BinOp           = 'BinOp';
    UnoOp           = 'UnoOp';
    FuncCall        = 'FuncCall';
    FuncArgList     = 'FuncArgList';
    LVal            = 'LVal';
    Dims            = 'Dims';
}

@lexer::header {
    package top.origami404.ssyc.frontend;
}

@parser::header {
    package top.origami404.ssyc.frontend;
}

BType: ('int' | 'float' | 'void');

Ident: ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '0'..'9' | '_')* ;

// See Ref: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf page 51
// the expoent part of hex style cannot be ignored
// the expoent part of hex style is still a `digit-sequence`, which `digit` is `DEC`
FloatConst: FloatDec | FloatHex ;
fragment FloatDec:               (DEC* '.' DEC*) (('e' | 'E') ('+' | '-')? DEC+)? ;
fragment FloatHex: ('0x' | '0X') (HEX* '.' HEX*)  ('p' | 'P') ('+' | '-')? DEC+   ;

// See Ref: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf page 54
// `0` is considered as an octal number
IntConst: IntDec | IntOct | IntHex ;
fragment IntDec: ('1'..'9') DEC* ;
fragment IntOct: '0' ('0'..'7')* ;
fragment IntHex: ('0x' | '0X') HEX+ ;

fragment DEC: '0'..'9';
fragment HEX: 'a'..'f' | 'A'..'F' | '0'..'9';

StrConst: '"' ~('"'|'\n')* '"' ;

// See Ref: http://index-of.es/Programming/Pragmatic%20Programmers/The%20Definitive%20ANTLR%20Reference.pdf page 101
// .* and .+ are defaultly not greedy
WS: (' ' | '\t' | '\n' | '\r')+     { skip(); } ;
LineComments: '//' .* '\n'          { skip(); } ;
BlockComments: '/*' .* '*/'         { skip(); } ;

//================== Parser ============================
compUnit: (decl | funcDef)* ;


//---------------- Declaration & Definition ------------
funcDef
    : BType Ident '(' funcParamList ')' block   -> ^(FuncDef BType Ident funcParamList block)
    ;

funcParamList
    : (funcParam (',' funcParam)*)?             -> ^(FuncParamList funcParam*)
    ;
funcParam
    : BType lVal                                -> ^(FuncParam BType lVal)
    ;

decl
    : 'const' BType (def (',' def)*) ';'    -> ^(ConstDef BType def)+
    | BType (def (',' def)*) ';'            -> ^(VarDef BType def)+
    ;

def
    : lVal ('=' initVal)?   -> lVal initVal?
    ;

initVal
    : exp                                   -> exp
    | '{' (initVal (',' initVal)*)? '}'     -> ^(InitList initVal*)
    ;


//---------------------------- stmt ---------------------
stmt
    : block                 -> block
    | stmtIf                -> stmtIf
    | stmtWhile             -> stmtWhile
    | stmtPutf              -> stmtPutf
    | exp ';'               -> ^(StmtExp exp)
    | lVal '=' exp ';'      -> ^(StmtAssign lVal exp)
    | ';'                   -> ^(StmtEmpty)
    | 'break'       ';'     -> ^(StmtBreak)
    | 'continue'    ';'     -> ^(StmtContinue)
    | 'return' exp? ';'     -> ^(StmtReturn exp?)
    ;

blockItem: (decl | stmt);
block
    : '{' blockItem* '}'       -> ^(Block blockItem*)
    ;

stmtIf
    : 'if' '(' cond ')' s1=stmt                 -> ^(StmtIf cond $s1 StmtEmpty)
    | 'if' '(' cond ')' s1=stmt 'else' s2=stmt  -> ^(StmtIf cond $s1 $s2)
    ;

stmtWhile
    : 'while' '(' cond ')' stmt                 -> ^(StmtWhile cond stmt)
    ;

stmtPutf
    : 'putf' '(' StrConst ',' funcArgList ')' ';'  -> ^(StmtPutf StrConst funcArgList)
    ;


//----------------- expression ----------------------------
cond
    : logOr     -> logOr
    ;

exp
    : expAdd    -> expAdd
    ;

logOr
    : logAnd '||' logOr     -> ^(LogOp '||' logAnd logOr)
    | logAnd                -> logAnd
    ;

logAnd
    : relEq '&&' logAnd     -> ^(LogOp '&&' relEq logAnd)
    | relEq                 -> relEq       
    ;

relEq
    : relComp '==' relEq    -> ^(RelOp '==' relComp relEq)
    | relComp '!=' relEq    -> ^(RelOp '!=' relComp relEq)
    | relComp               -> relComp
    ;

relComp
    : expAdd '<' relComp    -> ^(RelOp '<' expAdd relComp)
    | expAdd '>' relComp    -> ^(RelOp '>' expAdd relComp)
    | expAdd '<=' relComp   -> ^(RelOp '<=' expAdd relComp)
    | expAdd '>=' relComp   -> ^(RelOp '>=' expAdd relComp)
    | expAdd                -> expAdd
    ;

expAdd
    : expMul '+' expAdd -> ^(BinOp '+' expMul expAdd)
    | expMul '-' expAdd -> ^(BinOp '-' expMul expAdd)
    | expMul            -> expMul
    ;

expMul
    : expUnary '*' expMul   -> ^(BinOp '*' expUnary expMul)
    | expUnary '/' expMul   -> ^(BinOp '/' expUnary expMul)
    | expUnary '%' expMul   -> ^(BinOp '%' expUnary expMul)
    | expUnary              -> expUnary
    ;

expUnary
    : atom                      -> atom
    | '+' expUnary              -> ^(UnoOp '+' expUnary)
    | '-' expUnary              -> ^(UnoOp '-' expUnary)
    | '!' expUnary              -> ^(UnoOp '!' expUnary)
    | Ident '(' funcArgList ')' -> ^(FuncCall Ident funcArgList)
    ;

atom
    : '(' exp ')'   -> exp
    | lVal          -> lVal
    | IntConst      -> IntConst
    | FloatConst    -> FloatConst
    ;


//----------------- misc ----------------------------
funcArgList
    : (exp (',' exp)*)?         -> ^(FuncArgList exp*)
    ;

lVal
    : Ident ('[' exp ']')*      -> ^(LVal Ident ^(Dims exp*))
    ;
