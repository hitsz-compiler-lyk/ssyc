grammar SysY;

options {
    backtrack = true;
    memoize = true;
    output = AST;
    ASTLabelType = CommonTree;
}

tokens {
    FuncDef         = 'FuncDef';
    FuncParamList   = 'FuncParamList';
    FuncParam       = 'FuncParam';
    ConstDef        = 'ConstDef';
    VarDef          = 'VarDef';
    InitList        = 'InitList';
    Block           = 'Block';
    StmtExp         = 'StmtExp';
    StmtAssign      = 'StmtAssign';
    StmtEmpty       = 'StmtEmpty';
    StmtBreak       = 'StmtBreak';
    StmtContinue    = 'StmtContinue';
    StmtReturn      = 'StmtReturn';
    StmtEmpty       = 'StmtEmpty';
    StmtIf          = 'StmtIf';
    StmtWhile       = 'StmtWhile';
    StmtPutf        = 'StmtPutf';
    LogOp           = 'LogOp';
    RelOp           = 'RelOp';
    BinOp           = 'BinOp';
    UnoOp           = 'UnoOp';
    FuncCall        = 'FuncCall';
    FuncArgList     = 'FuncArgList';
    LVal            = 'LVal';
    Dims            = 'Dims';
}

@lexer::header {
    package top.origami404.ssyc.frontend;
}

@parser::header {
    package top.origami404.ssyc.frontend;
}

BType: ('int' | 'float' | 'void');

Ident: ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '0'..'9' | '_')* ;
IntConst: ('0'..'9')+ ;
FloatConst: ('0'..'9')+ '.' ('0'..'9')* ;
StrConst: '"' ~('"'|'\n')* '"' ;

WS: (' ' | '\t' | '\n' | '\r')+     { skip(); } ;

//================== Parser ============================
compUnit: (decl | funcDef)* ;


//---------------- Declaration & Definition ------------
funcDef
    : BType Ident '(' funcParamList ')' block   -> ^(FuncDef BType Ident funcParamList block)
    ;

funcParamList
    : (funcParam (',' funcParam)*)?             -> ^(FuncParamList funcParam*)
    ;
funcParam
    : BType lVal                                -> ^(FuncParam BType lVal)
    ;

decl
    : 'const' BType (def (',' def)*) ';'    -> ^(ConstDef BType def)+
    | BType (def (',' def)*) ';'            -> ^(VarDef BType def)+
    ;

def
    : lVal ('=' initVal)?   -> lVal initVal?
    ;

initVal
    : exp                                   -> exp
    | '{' (initVal (',' initVal)*)? '}'     -> ^(InitList initVal*)
    ;


//---------------------------- stmt ---------------------
stmt
    : block                 -> block
    | stmtIf                -> stmtIf
    | stmtWhile             -> stmtWhile
    | stmtPutf              -> stmtPutf
    | exp ';'               -> ^(StmtExp exp)
    | lVal '=' exp ';'      -> ^(StmtAssign lVal exp)
    | ';'                   -> ^(StmtEmpty)
    | 'break'       ';'     -> ^(StmtBreak)
    | 'continue'    ';'     -> ^(StmtContinue)
    | 'return' exp? ';'     -> ^(StmtReturn exp?)
    ;

blockItem: (decl | stmt);
block
    : '{' blockItem* '}'       -> ^(Block blockItem*)
    ;

stmtIf
    : 'if' '(' cond ')' s1=stmt                 -> ^(StmtIf cond $s1 StmtEmpty)
    | 'if' '(' cond ')' s1=stmt 'else' s2=stmt  -> ^(StmtIf cond $s1 $s2)
    ;

stmtWhile
    : 'while' '(' cond ')' stmt                 -> ^(StmtWhile cond stmt)
    ;

stmtPutf
    : 'putf' '(' StrConst ',' funcArgList ')' ';'  -> ^(StmtPutf StrConst funcArgList)
    ;


//----------------- expression ----------------------------
cond
    : logOr     -> logOr
    ;

exp
    : expAdd    -> expAdd
    ;

logOr
    : logAnd '||' logOr     -> ^(LogOp '||' logAnd logOr)
    | logAnd                -> logAnd
    ;

logAnd
    : relEq '&&' logAnd     -> ^(LogOp '&&' relEq logAnd)
    | relEq                 -> relEq       
    ;

relEq
    : relComp '==' relEq    -> ^(RelOp '==' relComp relEq)
    | relComp '!=' relEq    -> ^(RelOp '!=' relComp relEq)
    | relComp               -> relComp
    ;

relComp
    : expAdd '<' relComp    -> ^(RelOp '<' expAdd relComp)
    | expAdd '>' relComp    -> ^(RelOp '>' expAdd relComp)
    | expAdd '<=' relComp   -> ^(RelOp '<=' expAdd relComp)
    | expAdd '>=' relComp   -> ^(RelOp '>=' expAdd relComp)
    | expAdd                -> expAdd
    ;

expAdd
    : expMul '+' expAdd -> ^(BinOp '+' expMul expAdd)
    | expMul '-' expAdd -> ^(BinOp '-' expMul expAdd)
    | expMul            -> expMul
    ;

expMul
    : expUnary '*' expMul   -> ^(BinOp '*' expUnary expMul)
    | expUnary '/' expMul   -> ^(BinOp '/' expUnary expMul)
    | expUnary '%' expMul   -> ^(BinOp '%' expUnary expMul)
    | expUnary              -> expUnary
    ;

expUnary
    : atom                      -> atom
    | '+' expUnary              -> ^(UnoOp '+' expUnary)
    | '-' expUnary              -> ^(UnoOp '-' expUnary)
    | '!' expUnary              -> ^(UnoOp '!' expUnary)
    | Ident '(' funcArgList ')' -> ^(FuncCall Ident funcArgList)
    ;

atom
    : '(' exp ')'   -> exp
    | lVal          -> lVal
    | IntConst      -> IntConst
    | FloatConst    -> FloatConst
    ;


//----------------- misc ----------------------------
funcArgList
    : (exp (',' exp)*)?         -> ^(FuncArgList exp*)
    ;

lVal
    : Ident ('[' exp ']')*      -> ^(LVal Ident ^(Dims exp*))
    ;
