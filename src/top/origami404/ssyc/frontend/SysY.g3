grammar SysY;

options {
    output = AST;
    ASTLabelType = CommonTree;
}

@lexer::header {
    package top.origami404.ssyc.frontend.gen;
}

@parser::header {
    package top.origami404.ssyc.frontend.gen;
}

Ident: [a-zA-Z_] [a-zA-Z0-9_]* ;
IntConst: [0-9]+ ;
FloatConst: [0-9]+ '.' [0-9]* ;
StringConst: '"' [^"\n]* '"' ;

BType: ('int' | 'float' | 'void');


//================== Parser ============================
compUnit: (decl | funcDef)* ;


//---------------- Declaration & Definition ------------
funcDef: BType Ident '(' funcParamList ')' block;

funcParamList: (funcParam (',' funcParam)*)? ;
funcParam: BType lVal ;

decl: 'const'? BType def ';' ;

def: (defOne (',' defOne)*)? ;
defOne: lVal ('=' initVal)? ;

initVal
    : exp
    | '{' (initVal (',' initVal)*)? '}'
    ;


//---------------------------- stmt ---------------------
stmt
    : block
    | ifStmt
    | whileStmt
    | putfForm
    | exp ';'
    | lVal '=' exp ';'
    | ';'
    | 'break'       ';'
    | 'continue'    ';'
    | 'return' exp? ';'
    ;

block: '{' (decl | stmt)* '}' ;

ifStmt
    : 'if' '(' cond ')' stmt
    | 'if' '(' cond ')' stmt 'else' stmt
    ;

whileStmt: 'while' '(' cond ')' stmt ;

putfForm: 'putf' '(' String ',' funcArgs ')' ';' ;


//----------------- expression ----------------------------
cond: logOr;
exp: expAdd;

logOr
    : logAnd
    | logAnd '||' logOr
    ;

logAnd
    : relEq 
    | relEq '&&' logAnd
    ;

relEq
    : relComp
    | relComp '==' relEq
    | relComp '!=' relEq
    ;

relComp
    : expAdd
    | expAdd '<' relComp
    | expAdd '>' relComp
    | expAdd '<=' relComp
    | expAdd '<=' relComp
    ;

expAdd
    : expMul
    | expMul '+' expAdd
    | expMul '-' expAdd
    ;

expUnary
    : atom
    | '+' unaryExp
    | '-' unaryExp
    | '!' unaryExp
    | Ident '(' funcArgList ')'
    ;

atom
    : '(' exp ')'
    | lVal
    | IntConst
    | FloatConst
    ;


//----------------- misc ----------------------------
funcArgList: (exp (',' exp)*)?;

lVal: Ident ('[' exp ']')*;